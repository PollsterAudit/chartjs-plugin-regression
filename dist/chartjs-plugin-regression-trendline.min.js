(()=>{var e={457:e=>{const t={id:"regressionTrendline",afterDatasetsUpdate(e){const t=e.options.plugins?.regressionTrendline;if(!t?.enabled)return e.regressionTrendlineCacheType=null,void(e.regressionTrendlineCache=null);const r=t.span||.3;let a=null;"getZoomedScaleBounds"in e&&(a=e.getZoomedScaleBounds()),e.data.datasets.forEach(((n,s)=>{const i=n.data;if(!i?.length)return void(e.regressionTrendlineCache&&(e.regressionTrendlineCache[s]=null));if(n.regressionTrendline&&!n.regressionTrendline.showLine)return void(e.regressionTrendlineCache&&(e.regressionTrendlineCache[s]=null));if(!Array.isArray(i)||i.length<3)return void(e.regressionTrendlineCache&&(e.regressionTrendlineCache[s]=null));const o=i.map((e=>({x:"number"==typeof e.x?e.x:Number(e[0]),y:"number"==typeof e.y?e.y:Number(e[1]),weight:t.weightField&&null!=e[t.weightField]?Number(e[t.weightField]):1}))),l=[];for(const e of o)if(!l.includes(e.x)){if(null!==a&&null!==a.x&&(e.x<a.x.min||e.x>a.x.max))continue;if(l.push(e.x),l.length>100)break}if(l.length<=1)return void(e.regressionTrendlineCache&&(e.regressionTrendlineCache[s]=null));let c=l.length<4?"linear":t.type||"local";const h=t.degree??("local"===c?2:1),u=t.steps||Math.min(50,Math.max(2,l.length/2)),g=RegressionCalculator.computeRegression(o,c,h,r),p=e.scales.x.min,d=(e.scales.x.max-p)/u,m=[];for(let e=-1;e<=u+1;e++){const t=p+e*d,r=g.predict(t);isFinite(r)&&m.push({x:t,y:r})}e.regressionTrendlineCacheType=c,e.regressionTrendlineCache||(e.regressionTrendlineCache=[]),e.regressionTrendlineCache[s]=m}))},beforeDatasetsDraw(e){const t=e.options.plugins?.regressionTrendline;if(!t?.enabled)return;if(!e.regressionTrendlineCacheType||!e.regressionTrendlineCache)return;const{ctx:n}=e,s=e.regressionTrendlineCacheType,i=t.borderWidth||2;e.data.datasets.forEach(((o,l)=>{if(t.hidden||!e.isDatasetVisible(l))return;const c=t.color||o.borderColor||"rgba(0,0,0,0.6)",h=e.regressionTrendlineCache[l];h&&(n.lineWidth=i,n.strokeStyle=c,"linear"===s||"exponential"===s||"logarithmic"===s||"power"===s?r(n,h,(t=>e.scales.x.getPixelForValue(t.x)),(t=>e.scales.y.getPixelForValue(t.y)),e.chartArea):a(n,h,(t=>e.scales.x.getPixelForValue(t.x)),(t=>e.scales.y.getPixelForValue(t.y)),e.chartArea),n.save(),n.restore())}))}};class WeightStrategies{static constant=e=>1;static property=(e="weight")=>t=>t[e]??1;static precision=(e="size",t="error")=>r=>{const a=r[e]??0,n=r[t]??0;return n<=0?a:a/Math.pow(n,2)};static inverseError=(e="error",t=0)=>r=>{const a=r[e]??t;return isFinite(a)?1/(1+a):1};static scaled=(e="size",t=1e3)=>r=>{const a=r[e]??0;return Math.min(a/t,1)};static scaledInverseError=(e="size",t="error",r=1e3)=>a=>{const n=a[e]??0,s=a[t]??0;return Math.min(n/r,1)*(1/(1+s))};static logScaled=(e="size")=>t=>{const r=t[e]??0;return Math.log(r+1)};static custom=e=>t=>{try{return e(t)}catch{return 1}};static calculateSoftmaxWeights(e){const t=Math.max(...e),r=e.map((e=>Math.exp(e-t))),a=r.reduce(((e,t)=>e+t),0);return r.map((e=>e/a))}static calculateZScoreWeights(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,r=Math.sqrt(e.map((e=>(e-t)**2)).reduce(((e,t)=>e+t))/e.length);return e.map((e=>(e-t)/(r||1)))}static calculateTScoreWeights(e){const t=e.length,r=e.reduce(((e,t)=>e+t),0)/t,a=Math.sqrt(e.map((e=>(e-r)**2)).reduce(((e,t)=>e+t),0)/t);return e.map((e=>(e-r)/((a||1)/Math.sqrt(t))))}static calculateCoefficientOfVariationWeights(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,r=Math.sqrt(e.map((e=>(e-t)**2)).reduce(((e,t)=>e+t),0)/e.length)/(t||1);return e.map((()=>1/(1+Math.abs(r))))}static calculateMinMaxWeights(e){const t=Math.min(...e),r=Math.max(...e);return r===t?e.map((()=>1)):e.map((e=>(e-t)/(r-t)))}static calculateStudentizedResidualWeights(e,t){if(e.length!==t.length)throw new Error("Values and predictions arrays must have the same length.");const r=e.map(((e,r)=>e-t[r])),a=Math.sqrt(r.map((e=>e**2)).reduce(((e,t)=>e+t),0)/e.length);return r.map((e=>1/(1+Math.abs(e/(a||1e-6)))))}static calculateStandardizedMomentWeights(e,t=3){const r=e.length,a=e.reduce(((e,t)=>e+t),0)/r,n=Math.sqrt(e.map((e=>(e-a)**2)).reduce(((e,t)=>e+t),0)/r),s=e.map((e=>(e-a)**t)).reduce(((e,t)=>e+t),0)/r/Math.pow(n||1e-6,t);return e.map((()=>1/(1+Math.abs(s))))}static normalizeWeights(e){const t=Math.max(...e);return e.map((e=>e/(t||1)))}static combineWeightFns(e=[],t=e=>e.reduce(((e,t)=>e*t),1)){return r=>t(e.map((e=>e(r))))}static calculateWeightsFn(e,t,r){const a={},n=[];e.forEach((e=>{const r=t[e];a[e]=r,n.push(r)}));const s=r(n),i={};return e.reverse().forEach((e=>{i[e]=s.pop()})),e=>i[e]}static applyWeights(e,t){return e.map((e=>({...e,weight:t(e)})))}}class RegressionCalculator{static computeRegression(e,t="linear",r=2,a=.3){const n=Math.min(...e.map((e=>e.x))),s=e.map((e=>({...e,x:e.x-n}))),i="local"===t?RegressionCalculator.#e(s,r,a):RegressionCalculator.#t(s,t,r);return{predict:e=>i.predict(e-n),equation:i.equation}}static#e(e,t="linear",r=2,a=.3){return{predict(t){const n=e.map((e=>Math.abs(e.x-t))).map(((e,t)=>({index:t,dist:e}))).sort(((e,t)=>e.dist-t.dist)),s=Math.floor(a*e.length),i=n[s-1]?.dist||1e-10,o=e=>{const t=1-Math.pow(e/i,3);return Math.pow(Math.max(0,t),3)},l=new Array(s),c=new Array(s),h=new Array(s);for(let a=0;a<s;a++){const{index:s}=n[a],i=e[s].x,u=e[s].y,g=e[s].weight||1,p=Math.abs(i-t);l[a]=o(p)*g,c[a]=Array.from({length:r+1},((e,t)=>Math.pow(i,t))),h[a]=u}const u=RegressionCalculator.#r(c).map(((e,t)=>e.map(((e,t)=>e*l[t])))),g=RegressionCalculator.#a(u,c),p=u.map((e=>e.reduce(((e,t,r)=>e+t*h[r]),0)));return RegressionCalculator.#n(g,p).reduce(((e,r,a)=>e+r*t**a),0)},equation:`local regression (degree ${r}, span ${a})`}}static#t(e,t,r){const a=e.map((e=>e.x)),n=e.map((e=>e.y)),s=e.map((e=>e.weight||1)),i=e=>e.reduce(((e,t,r)=>e+t*s[r]),0),o=s.reduce(((e,t)=>e+t),0),l=e=>i(e)/o;if("linear"===t){const e=l(a),t=l(n),r=i(a.map((t=>(t-e)**2)));if(Math.abs(r)<1e-10)return{predict:()=>t,equation:`y = ${t.toFixed(2)} (flat line)`};const s=i(a.map(((r,a)=>(r-e)*(n[a]-t))))/r,o=t-s*e;return{predict:e=>s*e+o,equation:`y = ${s.toFixed(2)}x + ${o.toFixed(2)}`}}if("exponential"===t){const t=n.map((e=>Math.log(e))),r=RegressionCalculator.#t(e.map(((e,r)=>({x:e.x,y:t[r],weight:s[r]}))),"linear");return{predict:e=>Math.exp(r.predict(e)),equation:`y = exp(${r.equation})`}}if("logarithmic"===t){const t=a.map((e=>Math.log(e))),r=RegressionCalculator.#t(e.map(((e,r)=>({x:t[r],y:n[r],weight:s[r]}))),"linear");return{predict:e=>r.predict(Math.log(e)),equation:`y = ${r.equation} (log x)`}}if("power"===t){const t=a.map((e=>Math.log(e))),r=n.map((e=>Math.log(e))),i=RegressionCalculator.#t(e.map(((e,a)=>({x:t[a],y:r[a],weight:s[a]}))),"linear");return{predict:e=>Math.exp(i.predict(Math.log(e))),equation:`y = exp(${i.equation})`}}if("polynomial"===t){const e=[],t=[];for(let i=0;i<a.length;i++){const o=Math.sqrt(s[i]);e[i]=[];for(let t=0;t<=r;t++)e[i][t]=o*Math.pow(a[i],t);t[i]=o*n[i]}const i=e[0].map(((t,r)=>e.map((e=>e[r])))),o=i.map((e=>i.map((t=>e.reduce(((e,r,a)=>e+r*t[a]),0))))),l=i.map((e=>e.reduce(((e,r,a)=>e+r*t[a]),0))),c=RegressionCalculator.#n(o,l);return{predict:e=>c.reduce(((t,r,a)=>t+r*e**a),0),equation:`y = ${c.map(((e,t)=>`${e.toFixed(2)}x^${t}`)).join(" + ")}`}}throw new Error(`Unsupported regression type: ${t}`)}static#r(e){return e[0].map(((t,r)=>e.map((e=>e[r]))))}static#a(e,t){const r=Array(e.length).fill(0).map((()=>Array(t[0].length).fill(0)));for(let a=0;a<e.length;a++)for(let n=0;n<t[0].length;n++)for(let s=0;s<e[0].length;s++)r[a][n]+=e[a][s]*t[s][n];return r}static#n(e,t){const r=e.length;for(let a=0;a<r;a++)e[a]=[...e[a],t[a]];for(let t=0;t<r;t++){let a=t;for(let n=t+1;n<r;n++)Math.abs(e[n][t])>Math.abs(e[a][t])&&(a=n);[e[t],e[a]]=[e[a],e[t]];const n=e[t][t];for(let a=0;a<=r;a++)e[t][a]/=n;for(let a=0;a<r;a++)if(a!==t){const n=e[a][t];for(let s=0;s<=r;s++)e[a][s]-=n*e[t][s]}}return e.map((e=>e[r]))}}const r=(e,t,r,a,n)=>{if(t.length<2)return;const s=(e,t,r)=>Math.max(t,Math.min(r,e));e.beginPath();for(let i=0;i<t.length-1;i++){const o=t[i],l=s(r(o),n.left,n.right),c=s(a(o),n.top,n.bottom);0===i?e.moveTo(l,c):e.lineTo(l,c)}e.stroke()},a=(e,t,r,a,n)=>{if(t.length<4)return;const s=(e,t,r)=>Math.max(t,Math.min(r,e)),i=new Path2D,o=.5;i.moveTo(s(r(t[0]),n.left,n.right),s(a(t[0]),n.top,n.bottom));for(let e=0;e<t.length-1;e++){const l=t[e-1]||t[e],c=t[e],h=t[e+1]||c,u=t[e+2]||h,g=r(c),p=a(c),d=r(h),m=a(h),f=g+(d-r(l))/6*o,x=d-(r(u)-g)/6*o,M=p+(m-a(l))/6*o,y=m-(a(u)-p)/6*o;i.bezierCurveTo(s(f,n.left,n.right),s(M,n.top,n.bottom),s(x,n.left,n.right),s(y,n.top,n.bottom),s(d,n.left,n.right),s(m,n.top,n.bottom))}e.stroke(i)};"undefined"!=typeof window&&window.Chart&&(window.Chart.hasOwnProperty("register")?window.Chart.register(t):window.Chart.plugins.register(t),window.WeightStrategies=WeightStrategies);try{e.exports=t,e.exports=WeightStrategies}catch(e){}}},t={};(function r(a){var n=t[a];if(void 0!==n)return n.exports;var s=t[a]={exports:{}};return e[a](s,s.exports,r),s.exports})(457)})();