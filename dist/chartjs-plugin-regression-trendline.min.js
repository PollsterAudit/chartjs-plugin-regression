(()=>{"use strict";var e={28:(e,t,r)=>{r.d(t,{J:()=>a});class a{static transpose(e){return e[0].map(((t,r)=>e.map((e=>e[r]))))}static multiply(e,t){const r=Array(e.length).fill(0).map((()=>Array(t[0].length).fill(0)));for(let a=0;a<e.length;a++)for(let n=0;n<t[0].length;n++)for(let s=0;s<e[0].length;s++)r[a][n]+=e[a][s]*t[s][n];return r}static gaussJordanSolve(e,t){const r=e.length;for(let a=0;a<r;a++)e[a]=[...e[a],t[a]];for(let t=0;t<r;t++){let a=t;for(let n=t+1;n<r;n++)Math.abs(e[n][t])>Math.abs(e[a][t])&&(a=n);if([e[t],e[a]]=[e[a],e[t]],Math.abs(e[t][t])<1e-10)throw new Error("Matrix is singular or nearly singular");const n=e[t][t];for(let a=t;a<=r;a++)e[t][a]/=n;for(let a=0;a<r;a++)if(a!==t){const n=e[a][t];for(let s=t;s<=r;s++)e[a][s]-=n*e[t][s]}}return e.map((e=>e[r]))}}},44:(e,t,r)=>{var a=r(472);const n={id:"regressionTrendline",afterDatasetsUpdate(e){const t=e.options.plugins?.regressionTrendline;if(!t?.enabled)return e.regressionTrendlineCacheType=null,void(e.regressionTrendlineCache=null);const r=t.span||.3;let n=null;"getZoomedScaleBounds"in e&&(n=e.getZoomedScaleBounds()),e.data.datasets.forEach(((s,o)=>{const i=()=>e.regressionTrendlineCache&&(e.regressionTrendlineCache[o]=null),l=s.data;if(!l?.length)return void i();if(s.regressionTrendline&&!s.regressionTrendline.showLine)return void i();if(!Array.isArray(l)||l.length<3)return void i();const c=l.map((e=>({x:"number"==typeof e.x?e.x:Number(e[0]),y:"number"==typeof e.y?e.y:Number(e[1]),weight:t.weightField&&null!=e[t.weightField]?Number(e[t.weightField]):1}))),h=[];for(const e of c)if(!h.includes(e.x)){if(null!==n&&null!==n.x&&(e.x<n.x.min||e.x>n.x.max))continue;if(h.push(e.x),h.length>100)break}if(h.length<=1)return void i();let u=h.length<4?"linear":t.type||"local";const g=t.degree??("local"===u?2:1),p=t.steps||Math.min(50,Math.max(2,h.length/2)),d=a.O.computeRegression(c,u,g,r),m=e.scales.x.min,f=(e.scales.x.max-m)/p,x=[];for(let e=-1;e<=p+1;e++){const t=m+e*f,r=d(t);isFinite(r)&&x.push({x:t,y:r})}e.regressionTrendlineCacheType=u,e.regressionTrendlineCache||(e.regressionTrendlineCache=[]),e.regressionTrendlineCache[o]=x}))},beforeDatasetsDraw(e){const t=e.options.plugins?.regressionTrendline;if(!t?.enabled)return;if(!e.regressionTrendlineCacheType||!e.regressionTrendlineCache)return;const{ctx:r}=e,a=e.regressionTrendlineCacheType,n=t.borderWidth||2;e.data.datasets.forEach(((i,l)=>{if(t.hidden||!e.isDatasetVisible(l))return;const c=t.color||i.borderColor||"rgba(0,0,0,0.6)",h=e.regressionTrendlineCache[l];h&&(r.lineWidth=n,r.strokeStyle=c,"linear"===a||"exponential"===a||"logarithmic"===a||"power"===a?s(r,h,(t=>e.scales.x.getPixelForValue(t.x)),(t=>e.scales.y.getPixelForValue(t.y)),e.chartArea):o(r,h,(t=>e.scales.x.getPixelForValue(t.x)),(t=>e.scales.y.getPixelForValue(t.y)),e.chartArea),r.save(),r.restore())}))}},s=(e,t,r,a,n)=>{if(t.length<2)return;const s=(e,t,r)=>Math.max(t,Math.min(r,e));e.beginPath();for(let o=0;o<t.length-1;o++){const i=t[o],l=s(r(i),n.left,n.right),c=s(a(i),n.top,n.bottom);0===o?e.moveTo(l,c):e.lineTo(l,c)}e.stroke()},o=(e,t,r,a,n)=>{if(t.length<4)return;const s=(e,t,r)=>Math.max(t,Math.min(r,e)),o=new Path2D,i=.5;o.moveTo(s(r(t[0]),n.left,n.right),s(a(t[0]),n.top,n.bottom));for(let e=0;e<t.length-1;e++){const l=t[e-1]||t[e],c=t[e],h=t[e+1]||c,u=t[e+2]||h,g=r(c),p=a(c),d=r(h),m=a(h),f=g+(d-r(l))/6*i,x=d-(r(u)-g)/6*i,M=p+(m-a(l))/6*i,w=m-(a(u)-p)/6*i;o.bezierCurveTo(s(f,n.left,n.right),s(M,n.top,n.bottom),s(x,n.left,n.right),s(w,n.top,n.bottom),s(d,n.left,n.right),s(m,n.top,n.bottom))}e.stroke(o)};"undefined"!=typeof window&&window.Chart&&(window.Chart.hasOwnProperty("register")?window.Chart.register(n):window.Chart.plugins.register(n))},127:(e,t,r)=>{"undefined"==typeof window||window.WeightStrategies||(window.WeightStrategies=class{static constant=e=>1;static property=(e="weight")=>t=>t[e]??1;static precision=(e="size",t="error")=>r=>{const a=r[e]??0,n=r[t]??0;return n<=0?a:a/Math.pow(n,2)};static inverseError=(e="error",t=0)=>r=>{const a=r[e]??t;return isFinite(a)?1/(1+a):1};static scaled=(e="size",t=1e3)=>r=>{const a=r[e]??0;return Math.min(a/t,1)};static scaledInverseError=(e="size",t="error",r=1e3)=>a=>{const n=a[e]??0,s=a[t]??0;return Math.min(n/r,1)*(1/(1+s))};static logScaled=(e="size")=>t=>{const r=t[e]??0;return Math.log(r+1)};static custom=e=>t=>{try{return e(t)}catch{return 1}};static calculateSoftmaxWeights(e){const t=Math.max(...e),r=e.map((e=>Math.exp(e-t))),a=r.reduce(((e,t)=>e+t),0);return r.map((e=>e/a))}static calculateZScoreWeights(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,r=Math.sqrt(e.map((e=>(e-t)**2)).reduce(((e,t)=>e+t))/e.length);return e.map((e=>(e-t)/(r||1)))}static calculateTScoreWeights(e){const t=e.length,r=e.reduce(((e,t)=>e+t),0)/t,a=Math.sqrt(e.map((e=>(e-r)**2)).reduce(((e,t)=>e+t),0)/t);return e.map((e=>(e-r)/((a||1)/Math.sqrt(t))))}static calculateCoefficientOfVariationWeights(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,r=Math.sqrt(e.map((e=>(e-t)**2)).reduce(((e,t)=>e+t),0)/e.length)/(t||1);return e.map((()=>1/(1+Math.abs(r))))}static calculateMinMaxWeights(e){const t=Math.min(...e),r=Math.max(...e);return r===t?e.map((()=>1)):e.map((e=>(e-t)/(r-t)))}static calculateStudentizedResidualWeights(e,t){if(e.length!==t.length)throw new Error("Values and predictions arrays must have the same length.");const r=e.map(((e,r)=>e-t[r])),a=Math.sqrt(r.map((e=>e**2)).reduce(((e,t)=>e+t),0)/e.length);return r.map((e=>1/(1+Math.abs(e/(a||1e-6)))))}static calculateStandardizedMomentWeights(e,t=3){const r=e.length,a=e.reduce(((e,t)=>e+t),0)/r,n=Math.sqrt(e.map((e=>(e-a)**2)).reduce(((e,t)=>e+t),0)/r),s=e.map((e=>(e-a)**t)).reduce(((e,t)=>e+t),0)/r/Math.pow(n||1e-6,t);return e.map((()=>1/(1+Math.abs(s))))}static normalizeWeights(e){const t=Math.max(...e);return e.map((e=>e/(t||1)))}static combineWeightFns(e=[],t=e=>e.reduce(((e,t)=>e*t),1)){return r=>t(e.map((e=>e(r))))}static calculateWeightsFn(e,t,r){const a={},n=[];e.forEach((e=>{const r=t[e];a[e]=r,n.push(r)}));const s=r(n),o={};return e.reverse().forEach((e=>{o[e]=s.pop()})),e=>o[e]}static applyWeights(e,t){return e.map((e=>({...e,weight:t(e)})))}})},472:(e,t,r)=>{r.d(t,{O:()=>n});var a=r(28);class n{static computeRegression(e,t="linear",r=2,a=.3){const s=Math.min(...e.map((e=>e.x))),o=e.map((e=>({...e,x:e.x-s}))),i="local"===t?n.computeLocalRegression(o,r,a):n.fallbackRegression(o,t,r);return e=>i(e-s)}static computeLocalRegression(e,t=2,r=.3){return n=>{const s=e.map((e=>Math.abs(e.x-n))).map(((e,t)=>({index:t,dist:e}))).sort(((e,t)=>e.dist-t.dist)),o=Math.floor(r*e.length),i=s[o-1]?.dist||1e-10,l=e=>{const t=1-Math.pow(e/i,3);return Math.pow(Math.max(0,t),3)},c=new Array(o),h=new Array(o),u=new Array(o);for(let r=0;r<o;r++){const{index:a}=s[r],o=e[a].x,i=e[a].y,g=e[a].weight||1,p=Math.abs(o-n);c[r]=l(p)*g,h[r]=Array.from({length:t+1},((e,t)=>Math.pow(o,t))),u[r]=i}const g=a.J.transpose(h).map(((e,t)=>e.map(((e,t)=>e*c[t])))),p=a.J.multiply(g,h),d=g.map((e=>e.reduce(((e,t,r)=>e+t*u[r]),0)));return a.J.gaussJordanSolve(p,d).reduce(((e,t,r)=>e+t*n**r),0)}}static fallbackRegression(e,t,r){const s=e.map((e=>e.x)),o=e.map((e=>e.y)),i=e.map((e=>e.weight||1)),l=e=>e.reduce(((e,t,r)=>e+t*i[r]),0),c=i.reduce(((e,t)=>e+t),0),h=e=>l(e)/c;if("linear"===t){const e=h(s),t=h(o),r=l(s.map((t=>(t-e)**2)));if(Math.abs(r)<1e-10)return()=>t;const a=l(s.map(((r,a)=>(r-e)*(o[a]-t))))/r,n=t-a*e;return e=>a*e+n}if("exponential"===t){const t=o.map((e=>Math.log(e))),r=n.fallbackRegression(e.map(((e,r)=>({x:e.x,y:t[r],weight:i[r]}))),"linear");return e=>Math.exp(r(e))}if("logarithmic"===t){const t=s.map((e=>Math.log(e))),r=n.fallbackRegression(e.map(((e,r)=>({x:t[r],y:o[r],weight:i[r]}))),"linear");return e=>r(Math.log(e))}if("power"===t){const t=s.map((e=>Math.log(e))),r=o.map((e=>Math.log(e))),a=n.fallbackRegression(e.map(((e,a)=>({x:t[a],y:r[a],weight:i[a]}))),"linear");return e=>Math.exp(a(Math.log(e)))}if("polynomial"===t){const e=[],t=[];for(let a=0;a<s.length;a++){const n=Math.sqrt(i[a]);e[a]=[];for(let t=0;t<=r;t++)e[a][t]=n*Math.pow(s[a],t);t[a]=n*o[a]}const n=e[0].map(((t,r)=>e.map((e=>e[r])))),l=n.map((e=>n.map((t=>e.reduce(((e,r,a)=>e+r*t[a]),0))))),c=n.map((e=>e.reduce(((e,r,a)=>e+r*t[a]),0))),h=a.J.gaussJordanSolve(l,c);return e=>h.reduce(((t,r,a)=>t+r*e**a),0)}throw new Error(`Unsupported regression type: ${t}`)}}}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var s=t[a]={exports:{}};return e[a](s,s.exports,r),s.exports}r.d=(e,t)=>{for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r(44),r(127),r(28),r(472)})();